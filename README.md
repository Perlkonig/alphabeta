# alphabeta
Minimax implementation using AlphaBeta in Node using asynchronous calls to customizable game logic, scoring, and move generation.


# Usage

Construct an alphabeta calculator like so:

	var config = {
		scoreFunction 		: scoreFunction,
		generateMoves		: generateMovesFunction,
		checkWinConditions 	: checkWinConditionsFunction
	}

	var alphabeta = require('alphabeta')( config );

That creates one instance of an alphabeta calculator which uses the scoring, move generation, and win condition checking that you provide.  If you want to make two different computer opponents battle eachother using two different strategies you'll want to create two instances of alphabeta each with its own configuration.


Setup or reset the alphabeta calculator with data like so:

	alphabeta.setup( state , depthParameter );

'state' your implementation of the state of your game.
'depthParameter' is optional (defaults to 1) and is the depth of search in moves.  Also known as look-ahead.



Call the alphabeta calculator like so:

	alphabeta.step( callback );

A typical callback is as follows:

function callback( done ) {
	if ( done === true ) {
		var bestNextStateAsGeneratedByGenerateMoves = alphabeta.best()
		// do something
	} else {
		// do something else
	}
}

'step' moves the calculator ahead by one step.  Depending on the number of moves generated and the depthParameter there could be hundreds, thousands, millions, or more steps needed before the calculator finishes.  alphabeta.best() returns the best state.


To execute all the steps until alphabeta has found the best move for the depth call stepAll like so:

	alphabeta.stepAll( callback );

A typical callback is as follows

function callback( beststate ) {
	// beststate is the best move as generated by generateMoves
}


The scoreFunction that you provide is an asynchronous function that evaluates a state like so:

	scoreFunction( state , scoreCallback ) {
		var scoreNumber = 0;
		// inspect state and modify the score
		scoreCallback( scoreNumber );
	}


The generateMovesFunction that you provide is a synchronous function that returns a list of possible states like so:

	generateMovesFunction( currentState ) {
		var nextPossibleStates = [];

		// use the currentState and possibly some other info to create new state objects
		// which would represent valid next states.  If this is a game, then the state
		// is the game board and move as an object

		// for ( item in a list of possible moves ) {
			// use item to create a new state
			// push state onto nextPossibleStates
		// }

		return nextPossibleStates;

	}
	nextPossibleStates = generateMovesFunction( currentState );


The checkWinConditionsFunction that you provide is a synchronous function that checks to see if the state is a good end state such as a winning move.  A psudo code implementation may look like so:

	checkWinConditionsFunction( state ) {
		if ( /* state is a win or positive end condition */ ) {
			return true; // anything truthy such as 'true' or a string specifying the reason
		} else {
			return false; // anything falsy such as null or undefined
		}
	}

If you want to know the best score found you can use 

	var score = alphabeta.alpha();

If you want to know the predicted final state if the everything unfolds as the alphabeta calculator predicts use:

	var state = alphabeta.prediction();
