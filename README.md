# alphabeta
Minimax implementation using AlphaBeta in Node using *asynchronous* calls to customizable game logic, scoring, and move generation.

The rational and motivation to use asynchronous calls (specifically to the scoring function) is to support integration with other processes such as DBs and REST calls whereby a scoring function uses a growing data lookup.  This cannot be accomplished in a synchronous way in javascript.

# Usage

## alphabeta configuration
Construct an alphabeta calculator like so:

	var config = {
		scoreFunction 		: scoreFunction,
		generateMoves		: generateMovesFunction,
		checkWinConditions 	: checkWinConditionsFunction
	}

	var alphabeta = require('alphabeta')( config );

That creates one instance of an alphabeta calculator which uses the scoring, move generation, and win condition checking that you provide.  If you want to make two different computer opponents battle eachother using two different strategies you'll want to create two instances of alphabeta each with its own configuration.

## alphabeta.setup
Each new turn or new problem will require you to set the current state of alphabeta.  You can reuse the previous configuration unless you want to change the logic (scoring, move generation) that is used.
Setup or reset the alphabeta calculator with data like so:

	alphabeta.setup( state , depthParameter );

'state' your implementation of the state of your game.
'depthParameter' is optional (defaults to 1) and is the depth of search in moves.  Also known as look-ahead.


## alphabeta.step
Call the alphabeta calculator like so:

	alphabeta.step( callback );

A typical callback is as follows:

function callback( done ) {
	if ( done === true ) {
		var bestNextStateAsGeneratedByGenerateMoves = alphabeta.best()
		// do something
	} else {
		// do something else
	}
}

'step' moves the calculator ahead by one step.  Depending on the number of moves generated and the depthParameter there could be hundreds, thousands, millions, or more steps needed before the calculator finishes.  alphabeta.best() returns the best state.

## alphabeta.stepAll
To execute all the steps until alphabeta has found the best move for the depth call stepAll like so:

	alphabeta.stepAll( callback );

A typical callback is as follows

function callback( beststate ) {
	// beststate is the best move as generated by generateMoves
}

## Configuration Functions
This is the specification of the configuration functions you pass to alphabeta

### scoreFunction
The scoreFunction that you provide is an asynchronous function that evaluates a state like so:

	scoreFunction( state , scoreCallback ) {
		var scoreNumber = 0;
		// inspect state and modify the score
		scoreCallback( scoreNumber );
	}

### generateMoves
The generateMovesFunction that you provide is a synchronous function that returns a list of possible states like so:

	generateMovesFunction( currentState ) {
		var nextPossibleStates = [];

		// use the currentState and possibly some 
		// other info to create new state objects
		// which would represent valid next states.
		// If this is a game, then the state
		// is the game board and move as an object

		// for ( item in a list of possible moves ) {
			// use item to create a new state
			// push state onto nextPossibleStates
		// }

		return nextPossibleStates;

	}
	nextPossibleStates = generateMovesFunction( currentState );

### checkWinConditionsFunction
The checkWinConditionsFunction that you provide is a synchronous function that checks to see if the state is a good end state such as a winning move.  A psudo code implementation may look like so:

	checkWinConditionsFunction( state ) {
		if ( /* state is a win or positive end condition */ ) {
			return true; // anything truthy such as 
						 //'true' or a string specifying the reason
		} else {
			return false; // anything falsy such as null or undefined
		}
	}

If you want to know the best score found you can use 

	var score = alphabeta.alpha();

If you want to know the predicted final state if the everything unfolds as the alphabeta calculator predicts use:

	var state = alphabeta.prediction();

# Example

Execute the *tic tac toe* example like so

	# player 1 and 2 both only get 1 look-ahead
	node example/tic_tac_toe.js 1 1

	# player 2 gets 3 look-aheads
	node example/tic_tac_toe.js 1 3

	# player 1 gets 3 look-aheads
	node example/tic_tac_toe.js 1 1

	# player 1 and 2 both only get 9 look-ahead
	node example/tic_tac_toe.js 9 9

# FAQ

*What is the state object?*  It is whatever you decided is best for your problem.  It is what **generateMovesFunction** creates and what **scoreFunction** takes as an argument.  If your problem is tic tac toe, then perhaps state contains the current board and some other data that you find interesting such as what the previous move was.

*Why is there a **.step(callback)** function and not just **.stepAll(callback)**?  Depending on the depthParameter and the average number of moves generated from **generateMovesFunction** calculating the best next state can take a very long time.  Using **.step(callback)** allows you to move the calculation forward towards completion without blocking and exit when you want, such as after 10 seconds.

*You use a move object in the tic tac toe example and not a state object, why?* It is just named differently but is is the state of the tic tac toe game.  I can see how that is confusing, but I wrote the example before thinking of how it would work with the naming convention in the documentation.

# References

* [Instructor: Patrick Winston from MIT](https://www.youtube.com/watch?v=STjW3eH0Cik)
* [Wikipedia entry for Minimax](https://en.wikipedia.org/wiki/Minimax)
